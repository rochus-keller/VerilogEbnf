// This file was automatically generated by VerilogEbnf; don't modify it!
#include <QStack>
#include <Verilog/VlSynTree.h>
COMPILER Verilog05

	Vl::SynTree d_root;
	QStack<Vl::SynTree*> d_stack;
	void addTerminal() {
		Vl::SynTree* n = new Vl::SynTree( d_cur ); d_stack.top()->d_children.append(n);
	}

TOKENS
  TPlus
  TMinus
  TBang
  TBangEq
  TBang2Eq
  TTilde
  TTildeBar
  TTildeAmp
  TTildeHat
  THat
  THatTilde
  TSlash
  TPercent
  TEq
  T2Eq
  T3Eq
  TAmp
  T2Amp
  T3Amp
  TBar
  T2Bar
  TStar
  T2Star
  TLt
  TLeq
  T2Lt
  T3Lt
  TGt
  TGeq
  T2Gt
  T3Gt
  THash
  TAt
  TQmark
  TEqGt
  TStarGt
  TMinusGt
  TLpar
  TRpar
  TLbrack
  TRbrack
  TLbrace
  TRbrace
  TLatt
  TRatt
  TLcmt
  TRcmt
  TComma
  TDot
  TSemi
  TColon
  TPlusColon
  TMinusColon
  Talways
  Tand
  Tassign
  Tautomatic
  Tbegin
  Tbuf
  Tbufif0
  Tbufif1
  Tcase
  Tcasex
  Tcasez
  Tcell
  Tcmos
  Tconfig
  Tdeassign
  Tdefault
  Tdefparam
  Tdesign
  Tdisable
  Tedge
  Telse
  Tend
  Tendcase
  Tendconfig
  Tendfunction
  Tendgenerate
  Tendmodule
  Tendprimitive
  Tendspecify
  Tendtable
  Tendtask
  Tevent
  Tfor
  Tforce
  Tforever
  Tfork
  Tfunction
  Tgenerate
  Tgenvar
  Thighz0
  Thighz1
  Tif
  Tifnone
  Tincdir
  Tinclude
  Tinitial
  Tinout
  Tinput
  Tinstance
  Tinteger
  Tjoin
  Tlarge
  Tliblist
  Tlibrary
  Tlocalparam
  Tmacromodule
  Tmedium
  Tmodule
  Tnand
  Tnegedge
  Tnmos
  Tnor
  Tnoshowcancelled
  Tnot
  Tnotif0
  Tnotif1
  Tor
  Toutput
  Tparameter
  Tpmos
  Tposedge
  Tprimitive
  Tpull0
  Tpull1
  Tpulldown
  Tpullup
  Tpulsestyle_onevent
  Tpulsestyle_ondetect
  Trcmos
  Treal
  Trealtime
  Treg
  Trelease
  Trepeat
  Trnmos
  Trpmos
  Trtran
  Trtranif0
  Trtranif1
  Tscalared
  Tshowcancelled
  Tsigned
  Tsmall
  Tspecify
  Tspecparam
  Tstrong0
  Tstrong1
  Tsupply0
  Tsupply1
  Ttable
  Ttask
  Ttime
  Ttran
  Ttranif0
  Ttranif1
  Ttri
  Ttri0
  Ttri1
  Ttriand
  Ttrior
  Ttrireg
  Tunsigned
  Tuse
  Tuwire
  Tvectored
  Twait
  Twand
  Tweak0
  Tweak1
  Twhile
  Twire
  Twor
  Txnor
  Txor
  TmaxKeyword
  TPathPulse
  TSetup
  THold
  TSetupHold
  TRecovery
  TRemoval
  TRecrem
  TSkew
  TTimeSkew
  TFullSkew
  TPeriod
  TWidth
  TNoChange
  TmaxSystemName
  TString
  TIdent
  TSysName
  TCoDi
  TRealnum
  TNatural
  TSizedBased
  TBasedInt
  TBaseFormat
  TBaseValue
  TAttribute
  TMacroUsage

PRODUCTIONS

Verilog05 = (. d_stack.push(&d_root); .) translation_unit (. d_stack.pop(); .) . 


identifier = 
    TIdent (. addTerminal(); .) 
    .

system_name = 
    TSysName (. addTerminal(); .) 
    .

real_number = 
    TRealnum (. addTerminal(); .) 
    .

natural_number = 
    TNatural (. addTerminal(); .) 
    .

sizedbased_number = 
    TSizedBased (. addTerminal(); .) 
    .

based_number = 
    TBasedInt (. addTerminal(); .) 
    .

base_format = 
    TBaseFormat (. addTerminal(); .) 
    .

base_value = 
    TBaseValue (. addTerminal(); .) 
    .

string = 
    TString (. addTerminal(); .) 
    .

unary_operator = 
    TPlus (. addTerminal(); .) 
    | TMinus (. addTerminal(); .) 
    | TBang (. addTerminal(); .) 
    | TTilde (. addTerminal(); .) 
    | TAmp (. addTerminal(); .) 
    | TTildeAmp (. addTerminal(); .) 
    | TBar (. addTerminal(); .) 
    | TTildeBar (. addTerminal(); .) 
    | THat (. addTerminal(); .) 
    | TTildeHat (. addTerminal(); .) 
    | THatTilde (. addTerminal(); .) 
    .

binary_operator = 
    TPlus (. addTerminal(); .) 
    | TMinus (. addTerminal(); .) 
    | TStar (. addTerminal(); .) 
    | TSlash (. addTerminal(); .) 
    | TPercent (. addTerminal(); .) 
    | T2Eq (. addTerminal(); .) 
    | TBangEq (. addTerminal(); .) 
    | T3Eq (. addTerminal(); .) 
    | TBang2Eq (. addTerminal(); .) 
    | T2Amp (. addTerminal(); .) 
    | T2Bar (. addTerminal(); .) 
    | T2Star (. addTerminal(); .) 
    | TLt (. addTerminal(); .) 
    | TLeq (. addTerminal(); .) 
    | TGt (. addTerminal(); .) 
    | TGeq (. addTerminal(); .) 
    | TAmp (. addTerminal(); .) 
    | TBar (. addTerminal(); .) 
    | THat (. addTerminal(); .) 
    | THatTilde (. addTerminal(); .) 
    | TTildeHat (. addTerminal(); .) 
    | T2Gt (. addTerminal(); .) 
    | T2Lt (. addTerminal(); .) 
    | T3Gt (. addTerminal(); .) 
    | T3Lt (. addTerminal(); .) 
    .

unary_module_path_operator = 
    TBang (. addTerminal(); .) 
    | TTilde (. addTerminal(); .) 
    | TAmp (. addTerminal(); .) 
    | TTildeAmp (. addTerminal(); .) 
    | TBar (. addTerminal(); .) 
    | TTildeBar (. addTerminal(); .) 
    | THat (. addTerminal(); .) 
    | TTildeHat (. addTerminal(); .) 
    | THatTilde (. addTerminal(); .) 
    .

binary_module_path_operator = 
    T2Eq (. addTerminal(); .) 
    | TBangEq (. addTerminal(); .) 
    | T2Amp (. addTerminal(); .) 
    | T2Bar (. addTerminal(); .) 
    | TAmp (. addTerminal(); .) 
    | TBar (. addTerminal(); .) 
    | THat (. addTerminal(); .) 
    | TTildeHat (. addTerminal(); .) 
    | THatTilde (. addTerminal(); .) 
    .

translation_unit = 
    { module_declaration 
    | udp_declaration 
    | config_declaration 
    | library_declaration 
    | include_statement } 
    .

library_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_library_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tlibrary (. addTerminal(); .) library_identifier file_path_spec { TComma (. addTerminal(); .) file_path_spec } [ TMinus (. addTerminal(); .) Tincdir (. addTerminal(); .) file_path_spec { TComma (. addTerminal(); .) file_path_spec } ] TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

include_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_include_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tinclude (. addTerminal(); .) file_path_spec TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

file_path_spec = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_file_path_spec, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( identifier 
    | string ) (. d_stack.pop(); .) 
    .

module_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( module_keyword module_identifier [ module_parameter_port_list ] [ TLpar (. addTerminal(); .) [ list_of_ports | list_of_port_declarations ] TRpar (. addTerminal(); .) ] TSemi (. addTerminal(); .) { module_item } Tendmodule (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

module_keyword = 
    Tmodule (. addTerminal(); .) 
    | Tmacromodule (. addTerminal(); .) 
    .

module_parameter_port_list = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_parameter_port_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( THash (. addTerminal(); .) TLpar (. addTerminal(); .) parameter_declaration { TComma (. addTerminal(); .) parameter_declaration } TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

list_of_ports = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_ports, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( port { TComma (. addTerminal(); .) [ port ] } ) (. d_stack.pop(); .) 
    .

list_of_port_declarations = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_port_declarations, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( port_declaration { TComma (. addTerminal(); .) port_declaration } ) (. d_stack.pop(); .) 
    .

port = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_port, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( port_expression 
    | TDot (. addTerminal(); .) port_identifier TLpar (. addTerminal(); .) [ port_expression ] TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

port_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_port_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( port_reference 
    | TLbrace (. addTerminal(); .) port_reference { TComma (. addTerminal(); .) port_reference } TRbrace (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

port_reference = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_port_reference, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( port_identifier [ TLbrack (. addTerminal(); .) constant_range_expression TRbrack (. addTerminal(); .) ] ) (. d_stack.pop(); .) 
    .

port_declaration = 
    inout_declaration 
    | input_declaration 
    | output_declaration 
    .

module_item = 
    port_declaration TSemi (. addTerminal(); .) 
    | non_port_module_item 
    .

module_or_generate_item = 
    module_or_generate_item_declaration 
    | local_parameter_declaration TSemi (. addTerminal(); .) 
    | parameter_override 
    | continuous_assign 
    | gate_instantiation 
    | module_or_udp_instantiation 
    | initial_construct 
    | always_construct 
    | loop_generate_construct 
    | conditional_generate_construct 
    .

module_or_generate_item_declaration = 
    net_declaration 
    | reg_declaration 
    | integer_declaration 
    | real_declaration 
    | time_declaration 
    | realtime_declaration 
    | event_declaration 
    | genvar_declaration 
    | task_declaration 
    | function_declaration 
    .

non_port_module_item = 
    module_or_generate_item 
    | generate_region 
    | specify_block 
    | parameter_declaration TSemi (. addTerminal(); .) 
    | specparam_declaration 
    .

parameter_override = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_parameter_override, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tdefparam (. addTerminal(); .) list_of_defparam_assignments TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

config_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_config_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tconfig (. addTerminal(); .) config_identifier TSemi (. addTerminal(); .) design_statement { config_rule_statement } Tendconfig (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

design_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_design_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tdesign (. addTerminal(); .) { [ library_identifier TDot (. addTerminal(); .) ] cell_identifier } TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

config_rule_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_config_rule_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( default_clause | inst_clause | cell_clause ) ( liblist_clause | use_clause ) TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

default_clause = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_default_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tdefault (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

inst_clause = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_inst_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tinstance (. addTerminal(); .) inst_name ) (. d_stack.pop(); .) 
    .

inst_name = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_inst_name, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( topmodule_identifier { TDot (. addTerminal(); .) instance_identifier } ) (. d_stack.pop(); .) 
    .

cell_clause = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_cell_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tcell (. addTerminal(); .) [ IF( peek(1) == _TIdent && peek(2) == _TDot ) library_identifier TDot (. addTerminal(); .) ] cell_identifier ) (. d_stack.pop(); .) 
    .

liblist_clause = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_liblist_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tliblist (. addTerminal(); .) { library_identifier } ) (. d_stack.pop(); .) 
    .

use_clause = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_use_clause, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tuse (. addTerminal(); .) [ IF( peek(1) == _TIdent && peek(2) == _TDot ) library_identifier TDot (. addTerminal(); .) ] cell_identifier [ TColon (. addTerminal(); .) Tconfig (. addTerminal(); .) ] ) (. d_stack.pop(); .) 
    .

local_parameter_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_local_parameter_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tlocalparam (. addTerminal(); .) ( [ Tsigned (. addTerminal(); .) ] [ range ] | parameter_type ) list_of_param_assignments ) (. d_stack.pop(); .) 
    .

parameter_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_parameter_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tparameter (. addTerminal(); .) ( [ Tsigned (. addTerminal(); .) ] [ range ] | parameter_type ) list_of_param_assignments ) (. d_stack.pop(); .) 
    .

specparam_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specparam_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tspecparam (. addTerminal(); .) [ range ] list_of_specparam_assignments TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

parameter_type = 
    Tinteger (. addTerminal(); .) 
    | Treal (. addTerminal(); .) 
    | Trealtime (. addTerminal(); .) 
    | Ttime (. addTerminal(); .) 
    .

inout_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_inout_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tinout (. addTerminal(); .) [ net_type ] [ Tsigned (. addTerminal(); .) ] [ range ] list_of_port_identifiers ) (. d_stack.pop(); .) 
    .

input_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_input_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tinput (. addTerminal(); .) [ net_type ] [ Tsigned (. addTerminal(); .) ] [ range ] list_of_port_identifiers ) (. d_stack.pop(); .) 
    .

output_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_output_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Toutput (. addTerminal(); .) ( [ net_type ] [ Tsigned (. addTerminal(); .) ] [ range ] list_of_port_identifiers | Treg (. addTerminal(); .) [ Tsigned (. addTerminal(); .) ] [ range ] list_of_variable_port_identifiers | output_variable_type list_of_variable_port_identifiers ) ) (. d_stack.pop(); .) 
    .

event_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_event_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tevent (. addTerminal(); .) list_of_event_identifiers TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

integer_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_integer_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tinteger (. addTerminal(); .) list_of_variable_identifiers TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

list_of_net_decl_assignments_or_identifiers = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_net_decl_assignments_or_identifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( net_identifier [ dimension { dimension } | TEq (. addTerminal(); .) expression ] { TComma (. addTerminal(); .) net_identifier [ dimension { dimension } | TEq (. addTerminal(); .) expression ] } ) (. d_stack.pop(); .) 
    .

net_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_net_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( net_type | Ttrireg (. addTerminal(); .) ) [ IF( peek(1) == _TLpar && ( peek(2) == _Tsupply1 || peek(2) == _Tsupply0 || peek(2) == _Tweak1 || peek(2) == _Tpull0 || peek(2) == _Tstrong0 || peek(2) == _Tpull1 || peek(2) == _Tstrong1 || peek(2) == _Thighz0 || peek(2) == _Tweak0 || peek(2) == _Thighz1 ) ) drive_strength ] [ charge_strength ] [ Tvectored (. addTerminal(); .) | Tscalared (. addTerminal(); .) ] [ Tsigned (. addTerminal(); .) ] [ range ] [ delay3 ] list_of_net_decl_assignments_or_identifiers TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

real_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_real_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Treal (. addTerminal(); .) list_of_real_identifiers TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

realtime_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_realtime_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Trealtime (. addTerminal(); .) list_of_real_identifiers TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

reg_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_reg_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Treg (. addTerminal(); .) [ Tsigned (. addTerminal(); .) ] [ range ] list_of_variable_identifiers TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

time_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_time_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Ttime (. addTerminal(); .) list_of_variable_identifiers TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

net_type = 
    Tsupply0 (. addTerminal(); .) 
    | Tsupply1 (. addTerminal(); .) 
    | Ttri (. addTerminal(); .) 
    | Ttriand (. addTerminal(); .) 
    | Ttrior (. addTerminal(); .) 
    | Ttri0 (. addTerminal(); .) 
    | Ttri1 (. addTerminal(); .) 
    | Tuwire (. addTerminal(); .) 
    | Twire (. addTerminal(); .) 
    | Twand (. addTerminal(); .) 
    | Twor (. addTerminal(); .) 
    .

output_variable_type = 
    Tinteger (. addTerminal(); .) 
    | Ttime (. addTerminal(); .) 
    .

real_type = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_real_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( real_identifier ( { dimension } | TEq (. addTerminal(); .) constant_expression ) ) (. d_stack.pop(); .) 
    .

variable_type = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_variable_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( variable_identifier ( { dimension } | TEq (. addTerminal(); .) constant_expression ) ) (. d_stack.pop(); .) 
    .

drive_strength = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_drive_strength, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TLpar (. addTerminal(); .) ( strength0 | strength1 | Thighz0 (. addTerminal(); .) | Thighz1 (. addTerminal(); .) ) TComma (. addTerminal(); .) ( strength1 | strength0 | Thighz1 (. addTerminal(); .) | Thighz0 (. addTerminal(); .) ) TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

strength0 = 
    Tsupply0 (. addTerminal(); .) 
    | Tstrong0 (. addTerminal(); .) 
    | Tpull0 (. addTerminal(); .) 
    | Tweak0 (. addTerminal(); .) 
    .

strength1 = 
    Tsupply1 (. addTerminal(); .) 
    | Tstrong1 (. addTerminal(); .) 
    | Tpull1 (. addTerminal(); .) 
    | Tweak1 (. addTerminal(); .) 
    .

charge_strength = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_charge_strength, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TLpar (. addTerminal(); .) ( Tsmall (. addTerminal(); .) | Tmedium (. addTerminal(); .) | Tlarge (. addTerminal(); .) ) TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

delay = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delay, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( THash (. addTerminal(); .) [ delay_value ] [ TLpar (. addTerminal(); .) mintypmax_expression { TComma (. addTerminal(); .) mintypmax_expression } TRpar (. addTerminal(); .) { expression_nlr } ] ) (. d_stack.pop(); .) 
    .

delay3 = 
    delay 
    .

delay2 = 
    delay 
    .

delay_value = 
    unsigned_or_real_number 
    | identifier 
    .

list_of_defparam_assignments = 
    defparam_assignment { TComma (. addTerminal(); .) defparam_assignment } 
    .

list_of_event_identifiers = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_event_identifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( event_identifier { dimension } { TComma (. addTerminal(); .) event_identifier { dimension } } ) (. d_stack.pop(); .) 
    .

list_of_param_assignments = 
    param_assignment { IF( peek(1) == _TComma && peek(2) == _TIdent ) TComma (. addTerminal(); .) param_assignment } 
    .

list_of_port_identifiers = 
    port_identifier { IF( peek(1) == _TComma && peek(2) == _TIdent ) TComma (. addTerminal(); .) port_identifier } 
    .

list_of_real_identifiers = 
    real_type { TComma (. addTerminal(); .) real_type } 
    .

list_of_specparam_assignments = 
    specparam_assignment { TComma (. addTerminal(); .) specparam_assignment } 
    .

list_of_variable_identifiers = 
    variable_type { TComma (. addTerminal(); .) variable_type } 
    .

list_of_variable_port_identifiers = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_list_of_variable_port_identifiers, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( port_identifier [ TEq (. addTerminal(); .) constant_expression ] { IF( peek(1) == _TComma && peek(2) == _TIdent ) TComma (. addTerminal(); .) port_identifier [ TEq (. addTerminal(); .) constant_expression ] } ) (. d_stack.pop(); .) 
    .

defparam_assignment = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_defparam_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( hierarchical_parameter_identifier TEq (. addTerminal(); .) constant_mintypmax_expression ) (. d_stack.pop(); .) 
    .

param_assignment = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_param_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( parameter_identifier TEq (. addTerminal(); .) constant_mintypmax_expression ) (. d_stack.pop(); .) 
    .

specparam_assignment = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specparam_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( specparam_identifier TEq (. addTerminal(); .) constant_mintypmax_expression 
    | pulse_control_specparam ) (. d_stack.pop(); .) 
    .

pulse_control_specparam = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pulse_control_specparam, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TPathPulse (. addTerminal(); .) TEq (. addTerminal(); .) TLpar (. addTerminal(); .) reject_limit_value [ TComma (. addTerminal(); .) error_limit_value ] TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

error_limit_value = 
    limit_value 
    .

reject_limit_value = 
    limit_value 
    .

limit_value = 
    constant_mintypmax_expression 
    .

dimension = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dimension, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TLbrack (. addTerminal(); .) dimension_constant_expression TColon (. addTerminal(); .) dimension_constant_expression TRbrack (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

range = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_range, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TLbrack (. addTerminal(); .) msb_constant_expression TColon (. addTerminal(); .) lsb_constant_expression TRbrack (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

function_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_function_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tfunction (. addTerminal(); .) [ Tautomatic (. addTerminal(); .) ] [ function_range_or_type ] function_identifier [ TLpar (. addTerminal(); .) function_port_list TRpar (. addTerminal(); .) ] TSemi (. addTerminal(); .) { function_item_declaration } function_statement Tendfunction (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

function_item_declaration = 
    block_item_declaration 
    | tf_input_declaration TSemi (. addTerminal(); .) 
    .

function_port_list = 
    tf_input_declaration { TComma (. addTerminal(); .) tf_input_declaration } 
    .

function_range_or_type = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_function_range_or_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ Tsigned (. addTerminal(); .) ] [ range ] 
    | Tinteger (. addTerminal(); .) 
    | Treal (. addTerminal(); .) 
    | Trealtime (. addTerminal(); .) 
    | Ttime (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

task_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_task_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Ttask (. addTerminal(); .) [ Tautomatic (. addTerminal(); .) ] task_identifier [ TLpar (. addTerminal(); .) [ task_port_list ] TRpar (. addTerminal(); .) ] TSemi (. addTerminal(); .) { task_item_declaration } statement_or_null Tendtask (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

task_item_declaration = 
    block_item_declaration 
    | tf_input_declaration TSemi (. addTerminal(); .) 
    | tf_output_declaration TSemi (. addTerminal(); .) 
    | tf_inout_declaration TSemi (. addTerminal(); .) 
    .

task_port_list = 
    task_port_item { TComma (. addTerminal(); .) task_port_item } 
    .

task_port_item = 
    tf_input_declaration 
    | tf_output_declaration 
    | tf_inout_declaration 
    .

tf_input_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_tf_input_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tinput (. addTerminal(); .) ( [ Treg (. addTerminal(); .) ] [ Tsigned (. addTerminal(); .) ] [ range ] | task_port_type ) list_of_port_identifiers ) (. d_stack.pop(); .) 
    .

tf_output_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_tf_output_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Toutput (. addTerminal(); .) ( [ Treg (. addTerminal(); .) ] [ Tsigned (. addTerminal(); .) ] [ range ] | task_port_type ) list_of_port_identifiers ) (. d_stack.pop(); .) 
    .

tf_inout_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_tf_inout_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tinout (. addTerminal(); .) ( [ Treg (. addTerminal(); .) ] [ Tsigned (. addTerminal(); .) ] [ range ] | task_port_type ) list_of_port_identifiers ) (. d_stack.pop(); .) 
    .

task_port_type = 
    Tinteger (. addTerminal(); .) 
    | Treal (. addTerminal(); .) 
    | Trealtime (. addTerminal(); .) 
    | Ttime (. addTerminal(); .) 
    .

block_item_declaration = 
    block_reg_declaration 
    | block_integer_declaration 
    | block_time_declaration 
    | block_real_declaration 
    | block_realtime_declaration 
    | event_declaration 
    | local_parameter_declaration TSemi (. addTerminal(); .) 
    | parameter_declaration TSemi (. addTerminal(); .) 
    .

block_reg_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_reg_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Treg (. addTerminal(); .) [ Tsigned (. addTerminal(); .) ] [ range ] list_of_block_variable_identifiers TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

block_integer_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_integer_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tinteger (. addTerminal(); .) list_of_block_variable_identifiers TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

block_time_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_time_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Ttime (. addTerminal(); .) list_of_block_variable_identifiers TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

block_real_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_real_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Treal (. addTerminal(); .) list_of_block_real_identifiers TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

block_realtime_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_realtime_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Trealtime (. addTerminal(); .) list_of_block_real_identifiers TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

list_of_block_variable_identifiers = 
    block_variable_type { TComma (. addTerminal(); .) block_variable_type } 
    .

list_of_block_real_identifiers = 
    block_real_type { TComma (. addTerminal(); .) block_real_type } 
    .

block_variable_type = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_variable_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( variable_identifier { dimension } ) (. d_stack.pop(); .) 
    .

block_real_type = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_block_real_type, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( real_identifier { dimension } ) (. d_stack.pop(); .) 
    .

gate_instantiation = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_gate_instantiation, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( cmos_switchtype [ delay3 ] cmos_switch_instance { TComma (. addTerminal(); .) cmos_switch_instance } TSemi (. addTerminal(); .) 
    | enable_gatetype [ IF( peek(1) == _TLpar && ( peek(2) == _Tsupply1 || peek(2) == _Tsupply0 || peek(2) == _Tweak1 || peek(2) == _Tpull0 || peek(2) == _Tstrong0 || peek(2) == _Tpull1 || peek(2) == _Tstrong1 || peek(2) == _Thighz0 || peek(2) == _Tweak0 || peek(2) == _Thighz1 ) ) drive_strength ] [ delay3 ] enable_gate_instance { TComma (. addTerminal(); .) enable_gate_instance } TSemi (. addTerminal(); .) 
    | mos_switchtype [ delay3 ] mos_switch_instance { TComma (. addTerminal(); .) mos_switch_instance } TSemi (. addTerminal(); .) 
    | n_input_gatetype [ IF( peek(1) == _TLpar && ( peek(2) == _Tsupply1 || peek(2) == _Tsupply0 || peek(2) == _Tweak1 || peek(2) == _Tpull0 || peek(2) == _Tstrong0 || peek(2) == _Tpull1 || peek(2) == _Tstrong1 || peek(2) == _Thighz0 || peek(2) == _Tweak0 || peek(2) == _Thighz1 ) ) drive_strength ] [ delay2 ] n_input_gate_instance { TComma (. addTerminal(); .) n_input_gate_instance } TSemi (. addTerminal(); .) 
    | n_output_gatetype [ IF( peek(1) == _TLpar && ( peek(2) == _Tsupply1 || peek(2) == _Tsupply0 || peek(2) == _Tweak1 || peek(2) == _Tpull0 || peek(2) == _Tstrong0 || peek(2) == _Tpull1 || peek(2) == _Tstrong1 || peek(2) == _Thighz0 || peek(2) == _Tweak0 || peek(2) == _Thighz1 ) ) drive_strength ] [ delay2 ] n_output_gate_instance { TComma (. addTerminal(); .) n_output_gate_instance } TSemi (. addTerminal(); .) 
    | pass_en_switchtype [ delay2 ] pass_enable_switch_instance { TComma (. addTerminal(); .) pass_enable_switch_instance } TSemi (. addTerminal(); .) 
    | pass_switchtype pass_switch_instance { TComma (. addTerminal(); .) pass_switch_instance } TSemi (. addTerminal(); .) 
    | Tpulldown (. addTerminal(); .) [ IF( peek(1) == _TLpar && ( peek(2) == _Tsupply1 || peek(2) == _Tsupply0 || peek(2) == _Tweak1 || peek(2) == _Tpull0 || peek(2) == _Tstrong0 || peek(2) == _Tpull1 || peek(2) == _Tstrong1 || peek(2) == _Tweak0 ) ) pulldown_strength ] pull_gate_instance { TComma (. addTerminal(); .) pull_gate_instance } TSemi (. addTerminal(); .) 
    | Tpullup (. addTerminal(); .) [ IF( peek(1) == _TLpar && ( peek(2) == _Tsupply1 || peek(2) == _Tsupply0 || peek(2) == _Tweak1 || peek(2) == _Tpull0 || peek(2) == _Tstrong0 || peek(2) == _Tpull1 || peek(2) == _Tstrong1 || peek(2) == _Tweak0 ) ) pullup_strength ] pull_gate_instance { TComma (. addTerminal(); .) pull_gate_instance } TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

cmos_switch_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_cmos_switch_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ name_of_gate_instance ] TLpar (. addTerminal(); .) output_terminal TComma (. addTerminal(); .) input_terminal TComma (. addTerminal(); .) ncontrol_terminal TComma (. addTerminal(); .) pcontrol_terminal TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

enable_gate_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_enable_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ name_of_gate_instance ] TLpar (. addTerminal(); .) output_terminal TComma (. addTerminal(); .) input_terminal TComma (. addTerminal(); .) enable_terminal TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

mos_switch_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_mos_switch_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ name_of_gate_instance ] TLpar (. addTerminal(); .) output_terminal TComma (. addTerminal(); .) input_terminal TComma (. addTerminal(); .) enable_terminal TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

n_input_gate_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_n_input_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ name_of_gate_instance ] TLpar (. addTerminal(); .) output_terminal TComma (. addTerminal(); .) input_terminal { TComma (. addTerminal(); .) input_terminal } TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

input_or_output_terminal = 
    expression_2 
    .

n_output_gate_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_n_output_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ name_of_gate_instance ] TLpar (. addTerminal(); .) input_or_output_terminal { TComma (. addTerminal(); .) input_or_output_terminal } TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

pass_switch_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pass_switch_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ name_of_gate_instance ] TLpar (. addTerminal(); .) inout_terminal TComma (. addTerminal(); .) inout_terminal TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

pass_enable_switch_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pass_enable_switch_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ name_of_gate_instance ] TLpar (. addTerminal(); .) inout_terminal TComma (. addTerminal(); .) inout_terminal TComma (. addTerminal(); .) enable_terminal TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

pull_gate_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pull_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ name_of_gate_instance ] TLpar (. addTerminal(); .) output_terminal TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

name_of_gate_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_name_of_gate_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( gate_instance_identifier [ range ] ) (. d_stack.pop(); .) 
    .

pulldown_strength = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pulldown_strength, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TLpar (. addTerminal(); .) ( strength0 | strength1 ) [ TComma (. addTerminal(); .) ( strength1 | strength0 ) ] TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

pullup_strength = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pullup_strength, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TLpar (. addTerminal(); .) ( strength0 | strength1 ) [ TComma (. addTerminal(); .) ( strength1 | strength0 ) ] TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

enable_terminal = 
    expression 
    .

inout_terminal = 
    net_lvalue 
    .

input_terminal = 
    expression 
    .

ncontrol_terminal = 
    expression 
    .

output_terminal = 
    net_lvalue 
    .

pcontrol_terminal = 
    expression 
    .

cmos_switchtype = 
    Tcmos (. addTerminal(); .) 
    | Trcmos (. addTerminal(); .) 
    .

enable_gatetype = 
    Tbufif0 (. addTerminal(); .) 
    | Tbufif1 (. addTerminal(); .) 
    | Tnotif0 (. addTerminal(); .) 
    | Tnotif1 (. addTerminal(); .) 
    .

mos_switchtype = 
    Tnmos (. addTerminal(); .) 
    | Tpmos (. addTerminal(); .) 
    | Trnmos (. addTerminal(); .) 
    | Trpmos (. addTerminal(); .) 
    .

n_input_gatetype = 
    Tand (. addTerminal(); .) 
    | Tnand (. addTerminal(); .) 
    | Tor (. addTerminal(); .) 
    | Tnor (. addTerminal(); .) 
    | Txor (. addTerminal(); .) 
    | Txnor (. addTerminal(); .) 
    .

n_output_gatetype = 
    Tbuf (. addTerminal(); .) 
    | Tnot (. addTerminal(); .) 
    .

pass_en_switchtype = 
    Ttranif0 (. addTerminal(); .) 
    | Ttranif1 (. addTerminal(); .) 
    | Trtranif1 (. addTerminal(); .) 
    | Trtranif0 (. addTerminal(); .) 
    .

pass_switchtype = 
    Ttran (. addTerminal(); .) 
    | Trtran (. addTerminal(); .) 
    .

named_parameter_assignment = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_named_parameter_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TDot (. addTerminal(); .) parameter_identifier TLpar (. addTerminal(); .) [ mintypmax_expression ] TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

generate_region = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_generate_region, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tgenerate (. addTerminal(); .) { module_or_generate_item } Tendgenerate (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

genvar_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_genvar_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tgenvar (. addTerminal(); .) list_of_genvar_identifiers TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

list_of_genvar_identifiers = 
    genvar_identifier { TComma (. addTerminal(); .) genvar_identifier } 
    .

loop_generate_construct = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_loop_generate_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tfor (. addTerminal(); .) TLpar (. addTerminal(); .) genvar_initialization TSemi (. addTerminal(); .) genvar_expression TSemi (. addTerminal(); .) genvar_iteration TRpar (. addTerminal(); .) ( generate_block | module_or_generate_item ) ) (. d_stack.pop(); .) 
    .

genvar_initialization = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_genvar_initialization, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( genvar_identifier TEq (. addTerminal(); .) constant_expression ) (. d_stack.pop(); .) 
    .

genvar_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_genvar_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ unary_operator ] genvar_primary genvar_expression_nlr ) (. d_stack.pop(); .) 
    .

genvar_expression_nlr = 
    [ binary_operator genvar_expression genvar_expression_nlr 
    | TQmark (. addTerminal(); .) genvar_expression TColon (. addTerminal(); .) genvar_expression genvar_expression_nlr ] 
    .

genvar_iteration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_genvar_iteration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( genvar_identifier TEq (. addTerminal(); .) genvar_expression ) (. d_stack.pop(); .) 
    .

genvar_primary = 
    constant_primary 
    .

conditional_generate_construct = 
    if_generate_construct 
    | case_generate_construct 
    .

if_generate_construct = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_if_generate_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tif (. addTerminal(); .) TLpar (. addTerminal(); .) constant_expression TRpar (. addTerminal(); .) generate_block_or_null [ Telse (. addTerminal(); .) generate_block_or_null ] ) (. d_stack.pop(); .) 
    .

case_generate_construct = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_case_generate_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tcase (. addTerminal(); .) TLpar (. addTerminal(); .) constant_expression TRpar (. addTerminal(); .) case_generate_item { case_generate_item } Tendcase (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

case_generate_item = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_case_generate_item, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( constant_expression { TComma (. addTerminal(); .) constant_expression } TColon (. addTerminal(); .) generate_block_or_null 
    | Tdefault (. addTerminal(); .) [ TColon (. addTerminal(); .) ] generate_block_or_null ) (. d_stack.pop(); .) 
    .

generate_block = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_generate_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tbegin (. addTerminal(); .) [ TColon (. addTerminal(); .) generate_block_identifier ] { module_or_generate_item } Tend (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

generate_block_or_null = 
    generate_block 
    | module_or_generate_item 
    | TSemi (. addTerminal(); .) 
    .

udp_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tprimitive (. addTerminal(); .) udp_identifier TLpar (. addTerminal(); .) ( udp_port_list | udp_declaration_port_list ) TRpar (. addTerminal(); .) TSemi (. addTerminal(); .) { udp_port_declaration } udp_body Tendprimitive (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

udp_port_list = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_port_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( output_port_identifier TComma (. addTerminal(); .) input_port_identifier { TComma (. addTerminal(); .) input_port_identifier } ) (. d_stack.pop(); .) 
    .

udp_declaration_port_list = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_declaration_port_list, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( udp_output_declaration TComma (. addTerminal(); .) udp_input_declaration { TComma (. addTerminal(); .) udp_input_declaration } ) (. d_stack.pop(); .) 
    .

udp_port_declaration = 
    udp_output_declaration TSemi (. addTerminal(); .) 
    | udp_input_declaration TSemi (. addTerminal(); .) 
    | udp_reg_declaration TSemi (. addTerminal(); .) 
    .

udp_output_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_output_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Toutput (. addTerminal(); .) [ Treg (. addTerminal(); .) ] port_identifier [ TEq (. addTerminal(); .) constant_expression ] ) (. d_stack.pop(); .) 
    .

udp_input_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_input_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tinput (. addTerminal(); .) list_of_port_identifiers ) (. d_stack.pop(); .) 
    .

udp_reg_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_reg_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Treg (. addTerminal(); .) variable_identifier ) (. d_stack.pop(); .) 
    .

udp_body = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_body, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ udp_initial_statement ] Ttable (. addTerminal(); .) sequential_or_combinatorial_entry { sequential_or_combinatorial_entry } Tendtable (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

udp_initial_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_udp_initial_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tinitial (. addTerminal(); .) output_port_identifier TEq (. addTerminal(); .) init_val TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

sequential_or_combinatorial_entry = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_sequential_or_combinatorial_entry, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( { level_or_edge_symbol } [ TLpar (. addTerminal(); .) level_symbol [ level_symbol ] TRpar (. addTerminal(); .) ] { level_or_edge_symbol } TColon (. addTerminal(); .) ( level_symbol | TMinus (. addTerminal(); .) ) [ TColon (. addTerminal(); .) ( level_symbol | TMinus (. addTerminal(); .) ) ] TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

level_symbol = 
    number 
    | identifier 
    | TQmark (. addTerminal(); .) 
    .

level_or_edge_symbol = 
    number 
    | identifier 
    | TQmark (. addTerminal(); .) 
    | TStar (. addTerminal(); .) 
    .

edge_descriptor = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_edge_descriptor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( ( identifier | number ) [ identifier | number ] ) (. d_stack.pop(); .) 
    .

init_val = 
    number 
    .

scalar_constant = 
    number 
    .

continuous_assign = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_continuous_assign, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tassign (. addTerminal(); .) [ IF( peek(1) == _TLpar && ( peek(2) == _Tsupply1 || peek(2) == _Tsupply0 || peek(2) == _Tweak1 || peek(2) == _Tpull0 || peek(2) == _Tstrong0 || peek(2) == _Tpull1 || peek(2) == _Tstrong1 || peek(2) == _Thighz0 || peek(2) == _Tweak0 || peek(2) == _Thighz1 ) ) drive_strength ] [ delay3 ] list_of_net_assignments TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

list_of_net_assignments = 
    net_assignment { TComma (. addTerminal(); .) net_assignment } 
    .

net_assignment = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_net_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( net_lvalue TEq (. addTerminal(); .) expression ) (. d_stack.pop(); .) 
    .

initial_construct = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_initial_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tinitial (. addTerminal(); .) statement ) (. d_stack.pop(); .) 
    .

always_construct = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_always_construct, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Talways (. addTerminal(); .) statement ) (. d_stack.pop(); .) 
    .

procedural_continuous_assignments = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_procedural_continuous_assignments, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tassign (. addTerminal(); .) variable_assignment 
    | Tdeassign (. addTerminal(); .) variable_lvalue 
    | Tforce (. addTerminal(); .) variable_or_net_lvalue TEq (. addTerminal(); .) expression 
    | Trelease (. addTerminal(); .) variable_or_net_lvalue ) (. d_stack.pop(); .) 
    .

variable_assignment = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_variable_assignment, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( variable_lvalue TEq (. addTerminal(); .) expression ) (. d_stack.pop(); .) 
    .

par_block = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_par_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tfork (. addTerminal(); .) [ TColon (. addTerminal(); .) block_identifier { block_item_declaration } ] { statement } Tjoin (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

seq_block = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_seq_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tbegin (. addTerminal(); .) [ TColon (. addTerminal(); .) block_identifier { block_item_declaration } ] { statement } Tend (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

blocking_or_nonblocking_assignment_or_task_enable = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_blocking_or_nonblocking_assignment_or_task_enable, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( variable_lvalue [ TLpar (. addTerminal(); .) expression { TComma (. addTerminal(); .) expression } TRpar (. addTerminal(); .) ] [ ( TLeq (. addTerminal(); .) | TEq (. addTerminal(); .) ) [ delay_or_event_control ] [ expression ] ] TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

statement = 
    blocking_or_nonblocking_assignment_or_task_enable 
    | case_statement 
    | conditional_statement 
    | disable_statement 
    | event_trigger 
    | loop_statement 
    | par_block 
    | procedural_continuous_assignments TSemi (. addTerminal(); .) 
    | procedural_timing_control_statement 
    | seq_block 
    | system_task_enable 
    | wait_statement 
    | TSemi (. addTerminal(); .) 
    .

statement_or_null = 
    [ statement ] 
    .

function_statement = 
    statement 
    .

delay_control = 
    delay 
    .

delay_or_event_control = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delay_or_event_control, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( delay_control 
    | event_control 
    | Trepeat (. addTerminal(); .) TLpar (. addTerminal(); .) expression TRpar (. addTerminal(); .) event_control ) (. d_stack.pop(); .) 
    .

hierarchical_task_or_block_identifier = 
    hierarchical_identifier 
    .

disable_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_disable_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tdisable (. addTerminal(); .) hierarchical_task_or_block_identifier TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

event_control = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_event_control, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TAt (. addTerminal(); .) ( TLpar (. addTerminal(); .) ( event_expression | TStar (. addTerminal(); .) ) TRpar (. addTerminal(); .) | TStar (. addTerminal(); .) | hierarchical_event_identifier ) ) (. d_stack.pop(); .) 
    .

event_trigger = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_event_trigger, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TMinusGt (. addTerminal(); .) hierarchical_identifier_range TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

event_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_event_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( expression event_expression_nlr 
    | Tposedge (. addTerminal(); .) expression event_expression_nlr 
    | Tnegedge (. addTerminal(); .) expression event_expression_nlr ) (. d_stack.pop(); .) 
    .

event_expression_nlr = 
    [ Tor (. addTerminal(); .) event_expression event_expression_nlr 
    | TComma (. addTerminal(); .) event_expression event_expression_nlr ] 
    .

procedural_timing_control = 
    delay_control 
    | event_control 
    .

procedural_timing_control_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_procedural_timing_control_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( procedural_timing_control statement_or_null ) (. d_stack.pop(); .) 
    .

wait_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_wait_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Twait (. addTerminal(); .) TLpar (. addTerminal(); .) expression TRpar (. addTerminal(); .) statement_or_null ) (. d_stack.pop(); .) 
    .

conditional_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_conditional_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tif (. addTerminal(); .) TLpar (. addTerminal(); .) expression TRpar (. addTerminal(); .) statement_or_null [ Telse (. addTerminal(); .) statement_or_null ] ) (. d_stack.pop(); .) 
    .

case_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_case_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tcase (. addTerminal(); .) TLpar (. addTerminal(); .) expression TRpar (. addTerminal(); .) case_item { case_item } Tendcase (. addTerminal(); .) 
    | Tcasez (. addTerminal(); .) TLpar (. addTerminal(); .) expression TRpar (. addTerminal(); .) case_item { case_item } Tendcase (. addTerminal(); .) 
    | Tcasex (. addTerminal(); .) TLpar (. addTerminal(); .) expression TRpar (. addTerminal(); .) case_item { case_item } Tendcase (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

case_item = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_case_item, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( expression { TComma (. addTerminal(); .) expression } TColon (. addTerminal(); .) statement_or_null 
    | Tdefault (. addTerminal(); .) [ TColon (. addTerminal(); .) ] statement_or_null ) (. d_stack.pop(); .) 
    .

loop_statement = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_loop_statement, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tforever (. addTerminal(); .) statement 
    | Trepeat (. addTerminal(); .) TLpar (. addTerminal(); .) expression TRpar (. addTerminal(); .) statement 
    | Twhile (. addTerminal(); .) TLpar (. addTerminal(); .) expression TRpar (. addTerminal(); .) statement 
    | Tfor (. addTerminal(); .) TLpar (. addTerminal(); .) variable_assignment TSemi (. addTerminal(); .) expression TSemi (. addTerminal(); .) variable_assignment TRpar (. addTerminal(); .) statement ) (. d_stack.pop(); .) 
    .

system_task_enable = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_system_task_enable, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( system_task_identifier [ TLpar (. addTerminal(); .) [ expression ] { TComma (. addTerminal(); .) [ expression ] } TRpar (. addTerminal(); .) ] TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

specify_block = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specify_block, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tspecify (. addTerminal(); .) { specify_item } Tendspecify (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

specify_item = 
    specparam_declaration 
    | pulsestyle_declaration 
    | showcancelled_declaration 
    | path_declaration 
    | system_timing_check 
    .

pulsestyle_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_pulsestyle_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tpulsestyle_onevent (. addTerminal(); .) list_of_path_outputs TSemi (. addTerminal(); .) 
    | Tpulsestyle_ondetect (. addTerminal(); .) list_of_path_outputs TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

showcancelled_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_showcancelled_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tshowcancelled (. addTerminal(); .) list_of_path_outputs TSemi (. addTerminal(); .) 
    | Tnoshowcancelled (. addTerminal(); .) list_of_path_outputs TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

path_declaration = 
    simple_or_edge_sensitive_path_declaration TSemi (. addTerminal(); .) 
    | state_dependent_path_declaration TSemi (. addTerminal(); .) 
    .

parallel_or_full_path_description = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_parallel_or_full_path_description, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TLpar (. addTerminal(); .) list_of_path_inputs [ polarity_operator ] ( TEqGt (. addTerminal(); .) specify_output_terminal_descriptor | TStarGt (. addTerminal(); .) list_of_path_outputs ) TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

simple_path_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_simple_path_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( parallel_or_full_path_description TEq (. addTerminal(); .) path_delay_value ) (. d_stack.pop(); .) 
    .

list_of_path_inputs = 
    specify_input_terminal_descriptor { TComma (. addTerminal(); .) specify_input_terminal_descriptor } 
    .

list_of_path_outputs = 
    specify_output_terminal_descriptor { TComma (. addTerminal(); .) specify_output_terminal_descriptor } 
    .

specify_input_terminal_descriptor = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specify_input_terminal_descriptor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( input_identifier [ TLbrack (. addTerminal(); .) constant_range_expression TRbrack (. addTerminal(); .) ] ) (. d_stack.pop(); .) 
    .

specify_output_terminal_descriptor = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specify_output_terminal_descriptor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( output_identifier [ TLbrack (. addTerminal(); .) constant_range_expression TRbrack (. addTerminal(); .) ] ) (. d_stack.pop(); .) 
    .

input_or_inout_port_identifier = 
    identifier 
    .

input_identifier = 
    input_or_inout_port_identifier 
    .

output_or_inout_port_identifier = 
    identifier 
    .

output_identifier = 
    output_or_inout_port_identifier 
    .

path_delay_value = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_path_delay_value, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ TLpar (. addTerminal(); .) ] list_of_path_delay_expressions [ TRpar (. addTerminal(); .) ] ) (. d_stack.pop(); .) 
    .

list_of_path_delay_expressions = 
    path_delay_expression { TComma (. addTerminal(); .) path_delay_expression } 
    .

path_delay_expression = 
    constant_mintypmax_expression 
    .

simple_or_edge_sensitive_path_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_simple_or_edge_sensitive_path_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TLpar (. addTerminal(); .) [ edge_identifier ] list_of_path_inputs [ polarity_operator ] ( TEqGt (. addTerminal(); .) [ specify_output_terminal_descriptor ] | TStarGt (. addTerminal(); .) [ list_of_path_outputs ] ) [ TLpar (. addTerminal(); .) list_of_path_outputs ( TColon (. addTerminal(); .) | TPlusColon (. addTerminal(); .) | TMinusColon (. addTerminal(); .) ) data_source_expression TRpar (. addTerminal(); .) ] TRpar (. addTerminal(); .) TEq (. addTerminal(); .) path_delay_value ) (. d_stack.pop(); .) 
    .

simple_or_edge_sensitive_path_description = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_simple_or_edge_sensitive_path_description, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TLpar (. addTerminal(); .) [ edge_identifier ] list_of_path_inputs [ polarity_operator ] ( TEqGt (. addTerminal(); .) [ specify_output_terminal_descriptor ] | TStarGt (. addTerminal(); .) [ list_of_path_outputs ] ) [ TLpar (. addTerminal(); .) list_of_path_outputs ( TColon (. addTerminal(); .) | TPlusColon (. addTerminal(); .) | TMinusColon (. addTerminal(); .) ) data_source_expression TRpar (. addTerminal(); .) ] TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

data_source_expression = 
    expression 
    .

edge_identifier = 
    Tposedge (. addTerminal(); .) 
    | Tnegedge (. addTerminal(); .) 
    .

state_dependent_path_declaration = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_state_dependent_path_declaration, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tif (. addTerminal(); .) TLpar (. addTerminal(); .) module_path_expression TRpar (. addTerminal(); .) simple_or_edge_sensitive_path_description TEq (. addTerminal(); .) path_delay_value 
    | Tifnone (. addTerminal(); .) simple_path_declaration ) (. d_stack.pop(); .) 
    .

polarity_operator = 
    TPlus (. addTerminal(); .) 
    | TMinus (. addTerminal(); .) 
    .

system_timing_check = 
    dlr_setup_timing_check 
    | dlr_hold_timing_check 
    | dlr_setuphold_timing_check 
    | dlr_recovery_timing_check 
    | dlr_removal_timing_check 
    | dlr_recrem_timing_check 
    | dlr_skew_timing_check 
    | dlr_timeskew_timing_check 
    | dlr_fullskew_timing_check 
    | dlr_period_timing_check 
    | dlr_width_timing_check 
    | dlr_nochange_timing_check 
    .

dlr_setup_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_setup_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TSetup (. addTerminal(); .) TLpar (. addTerminal(); .) data_event TComma (. addTerminal(); .) reference_event TComma (. addTerminal(); .) timing_check_limit [ TComma (. addTerminal(); .) [ notifier ] ] TRpar (. addTerminal(); .) TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_hold_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_hold_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( THold (. addTerminal(); .) TLpar (. addTerminal(); .) reference_event TComma (. addTerminal(); .) data_event TComma (. addTerminal(); .) timing_check_limit [ TComma (. addTerminal(); .) [ notifier ] ] TRpar (. addTerminal(); .) TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_setuphold_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_setuphold_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TSetupHold (. addTerminal(); .) TLpar (. addTerminal(); .) reference_event TComma (. addTerminal(); .) data_event TComma (. addTerminal(); .) timing_check_limit TComma (. addTerminal(); .) timing_check_limit [ TComma (. addTerminal(); .) [ notifier ] [ TComma (. addTerminal(); .) [ stamptime_condition ] [ TComma (. addTerminal(); .) [ checktime_condition ] [ TComma (. addTerminal(); .) [ delayed_reference ] [ TComma (. addTerminal(); .) [ delayed_data ] ] ] ] ] ] TRpar (. addTerminal(); .) TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_recovery_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_recovery_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TRecovery (. addTerminal(); .) TLpar (. addTerminal(); .) reference_event TComma (. addTerminal(); .) data_event TComma (. addTerminal(); .) timing_check_limit [ TComma (. addTerminal(); .) [ notifier ] ] TRpar (. addTerminal(); .) TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_removal_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_removal_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TRemoval (. addTerminal(); .) TLpar (. addTerminal(); .) reference_event TComma (. addTerminal(); .) data_event TComma (. addTerminal(); .) timing_check_limit [ TComma (. addTerminal(); .) [ notifier ] ] TRpar (. addTerminal(); .) TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_recrem_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_recrem_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TRecrem (. addTerminal(); .) TLpar (. addTerminal(); .) reference_event TComma (. addTerminal(); .) data_event TComma (. addTerminal(); .) timing_check_limit TComma (. addTerminal(); .) timing_check_limit [ TComma (. addTerminal(); .) [ notifier ] [ TComma (. addTerminal(); .) [ stamptime_condition ] [ TComma (. addTerminal(); .) [ checktime_condition ] [ TComma (. addTerminal(); .) [ delayed_reference ] [ TComma (. addTerminal(); .) [ delayed_data ] ] ] ] ] ] TRpar (. addTerminal(); .) TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_skew_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_skew_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TSkew (. addTerminal(); .) TLpar (. addTerminal(); .) reference_event TComma (. addTerminal(); .) data_event TComma (. addTerminal(); .) timing_check_limit [ TComma (. addTerminal(); .) [ notifier ] ] TRpar (. addTerminal(); .) TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_timeskew_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_timeskew_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TTimeSkew (. addTerminal(); .) TLpar (. addTerminal(); .) reference_event TComma (. addTerminal(); .) data_event TComma (. addTerminal(); .) timing_check_limit [ TComma (. addTerminal(); .) [ notifier ] [ TComma (. addTerminal(); .) [ event_based_flag ] [ TComma (. addTerminal(); .) [ remain_active_flag ] ] ] ] TRpar (. addTerminal(); .) TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_fullskew_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_fullskew_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TFullSkew (. addTerminal(); .) TLpar (. addTerminal(); .) reference_event TComma (. addTerminal(); .) data_event TComma (. addTerminal(); .) timing_check_limit TComma (. addTerminal(); .) timing_check_limit [ TComma (. addTerminal(); .) [ notifier ] [ TComma (. addTerminal(); .) [ event_based_flag ] [ TComma (. addTerminal(); .) [ remain_active_flag ] ] ] ] TRpar (. addTerminal(); .) TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_period_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_period_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TPeriod (. addTerminal(); .) TLpar (. addTerminal(); .) controlled_reference_event TComma (. addTerminal(); .) timing_check_limit [ TComma (. addTerminal(); .) [ notifier ] ] TRpar (. addTerminal(); .) TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_width_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_width_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TWidth (. addTerminal(); .) TLpar (. addTerminal(); .) controlled_reference_event TComma (. addTerminal(); .) timing_check_limit [ TComma (. addTerminal(); .) threshold [ TComma (. addTerminal(); .) notifier ] ] TRpar (. addTerminal(); .) TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

dlr_nochange_timing_check = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_dlr_nochange_timing_check, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TNoChange (. addTerminal(); .) TLpar (. addTerminal(); .) reference_event TComma (. addTerminal(); .) data_event TComma (. addTerminal(); .) start_edge_offset TComma (. addTerminal(); .) end_edge_offset [ TComma (. addTerminal(); .) [ notifier ] ] TRpar (. addTerminal(); .) TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

checktime_condition = 
    mintypmax_expression 
    .

controlled_reference_event = 
    controlled_timing_check_event 
    .

data_event = 
    timing_check_event 
    .

delayed_data = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delayed_data, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( terminal_identifier [ TLbrack (. addTerminal(); .) constant_mintypmax_expression TRbrack (. addTerminal(); .) ] ) (. d_stack.pop(); .) 
    .

delayed_reference = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_delayed_reference, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( terminal_identifier [ TLbrack (. addTerminal(); .) constant_mintypmax_expression TRbrack (. addTerminal(); .) ] ) (. d_stack.pop(); .) 
    .

end_edge_offset = 
    mintypmax_expression 
    .

event_based_flag = 
    constant_expression 
    .

notifier = 
    variable_identifier 
    .

reference_event = 
    timing_check_event 
    .

remain_active_flag = 
    constant_expression 
    .

stamptime_condition = 
    mintypmax_expression 
    .

start_edge_offset = 
    mintypmax_expression 
    .

threshold = 
    constant_expression 
    .

timing_check_limit = 
    expression 
    .

timing_check_event = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_timing_check_event, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ timing_check_event_control ] specify_terminal_descriptor [ T3Amp (. addTerminal(); .) timing_check_condition ] ) (. d_stack.pop(); .) 
    .

controlled_timing_check_event = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_controlled_timing_check_event, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( timing_check_event_control specify_terminal_descriptor [ T3Amp (. addTerminal(); .) timing_check_condition ] ) (. d_stack.pop(); .) 
    .

timing_check_event_control = 
    Tposedge (. addTerminal(); .) 
    | Tnegedge (. addTerminal(); .) 
    | edge_control_specifier 
    .

specify_input_or_output_terminal_descriptor = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_specify_input_or_output_terminal_descriptor, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( identifier [ TLbrack (. addTerminal(); .) constant_range_expression TRbrack (. addTerminal(); .) ] ) (. d_stack.pop(); .) 
    .

specify_terminal_descriptor = 
    specify_input_or_output_terminal_descriptor 
    .

edge_control_specifier = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_edge_control_specifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( Tedge (. addTerminal(); .) TLbrack (. addTerminal(); .) edge_descriptor { TComma (. addTerminal(); .) edge_descriptor } TRbrack (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

timing_check_condition = 
    scalar_timing_check_condition 
    .

scalar_timing_check_condition = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_scalar_timing_check_condition, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( expression [ T2Eq (. addTerminal(); .) scalar_constant | T3Eq (. addTerminal(); .) scalar_constant | TBangEq (. addTerminal(); .) scalar_constant | TBang2Eq (. addTerminal(); .) scalar_constant ] ) (. d_stack.pop(); .) 
    .

constant_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_constant_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ unary_operator ] constant_primary { constant_expression_nlr } ) (. d_stack.pop(); .) 
    .

constant_expression_nlr = 
    binary_operator constant_expression 
    | TQmark (. addTerminal(); .) constant_expression TColon (. addTerminal(); .) constant_expression 
    .

constant_mintypmax_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_constant_mintypmax_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( constant_expression [ TColon (. addTerminal(); .) constant_expression TColon (. addTerminal(); .) constant_expression ] ) (. d_stack.pop(); .) 
    .

constant_range_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_constant_range_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( constant_expression [ TColon (. addTerminal(); .) lsb_constant_expression | TPlusColon (. addTerminal(); .) width_constant_expression | TMinusColon (. addTerminal(); .) width_constant_expression ] ) (. d_stack.pop(); .) 
    .

dimension_constant_expression = 
    constant_expression 
    .

expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ unary_operator ] primary { expression_nlr } ) (. d_stack.pop(); .) 
    .

expression_nlr = 
    binary_operator expression 
    | TQmark (. addTerminal(); .) expression TColon (. addTerminal(); .) expression 
    .

lsb_constant_expression = 
    constant_expression 
    .

mintypmax_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_mintypmax_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( expression [ TColon (. addTerminal(); .) expression TColon (. addTerminal(); .) expression ] ) (. d_stack.pop(); .) 
    .

module_path_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_path_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ unary_module_path_operator ] module_path_primary module_path_expression_nlr ) (. d_stack.pop(); .) 
    .

module_path_expression_nlr = 
    [ binary_module_path_operator module_path_expression module_path_expression_nlr 
    | TQmark (. addTerminal(); .) module_path_expression TColon (. addTerminal(); .) module_path_expression module_path_expression_nlr ] 
    .

module_path_mintypmax_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_path_mintypmax_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( module_path_expression [ TColon (. addTerminal(); .) module_path_expression TColon (. addTerminal(); .) module_path_expression ] ) (. d_stack.pop(); .) 
    .

msb_constant_expression = 
    constant_expression 
    .

range_expression = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_range_expression, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( expression [ TColon (. addTerminal(); .) lsb_constant_expression | TPlusColon (. addTerminal(); .) width_constant_expression | TMinusColon (. addTerminal(); .) width_constant_expression ] ) (. d_stack.pop(); .) 
    .

width_constant_expression = 
    constant_expression 
    .

constant_primary = 
    number 
    | string 
    | TLpar (. addTerminal(); .) constant_mintypmax_expression TRpar (. addTerminal(); .) 
    | ( identifier | system_name ) [ TLbrack (. addTerminal(); .) constant_range_expression TRbrack (. addTerminal(); .) | TLpar (. addTerminal(); .) constant_expression { TComma (. addTerminal(); .) constant_expression } TRpar (. addTerminal(); .) ] 
    | TLbrace (. addTerminal(); .) constant_expression [ TComma (. addTerminal(); .) constant_expression { TComma (. addTerminal(); .) constant_expression } | TLbrace (. addTerminal(); .) constant_expression { TComma (. addTerminal(); .) constant_expression } TRbrace (. addTerminal(); .) ] TRbrace (. addTerminal(); .) 
    .

primary = 
    ( hierarchical_identifier_range | system_function_identifier ) [ TLpar (. addTerminal(); .) expression { TComma (. addTerminal(); .) expression } TRpar (. addTerminal(); .) ] 
    | number 
    | string 
    | TLpar (. addTerminal(); .) mintypmax_expression TRpar (. addTerminal(); .) 
    | TLbrace (. addTerminal(); .) expression [ TComma (. addTerminal(); .) expression { TComma (. addTerminal(); .) expression } | TLbrace (. addTerminal(); .) expression { TComma (. addTerminal(); .) expression } TRbrace (. addTerminal(); .) ] TRbrace (. addTerminal(); .) 
    .

module_path_primary = 
    number 
    | ( hierarchical_identifier | system_function_identifier ) [ TLpar (. addTerminal(); .) expression { TComma (. addTerminal(); .) expression } TRpar (. addTerminal(); .) ] 
    | TLpar (. addTerminal(); .) module_path_mintypmax_expression TRpar (. addTerminal(); .) 
    | TLbrace (. addTerminal(); .) module_path_expression [ TComma (. addTerminal(); .) module_path_expression { TComma (. addTerminal(); .) module_path_expression } | TLbrace (. addTerminal(); .) module_path_expression { TComma (. addTerminal(); .) module_path_expression } TRbrace (. addTerminal(); .) ] TRbrace (. addTerminal(); .) 
    .

net_lvalue = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_net_lvalue, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( hierarchical_identifier_range_const 
    | TLbrace (. addTerminal(); .) net_lvalue { TComma (. addTerminal(); .) net_lvalue } TRbrace (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

variable_lvalue = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_variable_lvalue, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( hierarchical_identifier_range 
    | TLbrace (. addTerminal(); .) variable_lvalue { TComma (. addTerminal(); .) variable_lvalue } TRbrace (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

variable_or_net_lvalue = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_variable_or_net_lvalue, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( hierarchical_identifier_range 
    | TLbrace (. addTerminal(); .) variable_or_net_lvalue { TComma (. addTerminal(); .) variable_or_net_lvalue } TRbrace (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

number = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_number, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( real_number 
    | natural_number [ based_number | base_format ( base_value | natural_number ) ] 
    | sizedbased_number 
    | based_number 
    | base_format ( base_value | natural_number ) ) (. d_stack.pop(); .) 
    .

unsigned_or_real_number = 
    number 
    .

block_identifier = 
    identifier 
    .

cell_identifier = 
    identifier 
    .

config_identifier = 
    identifier 
    .

event_identifier = 
    identifier 
    .

function_identifier = 
    identifier 
    .

gate_instance_identifier = 
    identifier 
    .

generate_block_identifier = 
    identifier 
    .

genvar_identifier = 
    identifier 
    .

hierarchical_event_identifier = 
    hierarchical_identifier 
    .

hierarchical_identifier = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_hierarchical_identifier, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( identifier [ TLbrack (. addTerminal(); .) constant_expression TRbrack (. addTerminal(); .) ] { TDot (. addTerminal(); .) identifier [ TLbrack (. addTerminal(); .) constant_expression TRbrack (. addTerminal(); .) ] } ) (. d_stack.pop(); .) 
    .

hierarchical_identifier_range = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_hierarchical_identifier_range, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( identifier { TDot (. addTerminal(); .) identifier [ TLbrack (. addTerminal(); .) range_expression TRbrack (. addTerminal(); .) ] | TLbrack (. addTerminal(); .) range_expression TRbrack (. addTerminal(); .) } ) (. d_stack.pop(); .) 
    .

hierarchical_identifier_range_const = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_hierarchical_identifier_range_const, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( identifier { TDot (. addTerminal(); .) identifier [ TLbrack (. addTerminal(); .) constant_range_expression TRbrack (. addTerminal(); .) ] | TLbrack (. addTerminal(); .) constant_range_expression TRbrack (. addTerminal(); .) } ) (. d_stack.pop(); .) 
    .

hierarchical_parameter_identifier = 
    hierarchical_identifier 
    .

input_port_identifier = 
    identifier 
    .

instance_identifier = 
    identifier 
    .

library_identifier = 
    identifier 
    .

module_identifier = 
    identifier 
    .

net_identifier = 
    identifier 
    .

output_port_identifier = 
    identifier 
    .

parameter_identifier = 
    identifier 
    .

port_identifier = 
    identifier 
    .

real_identifier = 
    identifier 
    .

specparam_identifier = 
    identifier 
    .

task_identifier = 
    identifier 
    .

terminal_identifier = 
    identifier 
    .

topmodule_identifier = 
    identifier 
    .

udp_identifier = 
    identifier 
    .

variable_identifier = 
    identifier 
    .

system_function_identifier = 
    system_name 
    .

system_task_identifier = 
    system_name 
    .

module_or_udp_instantiation = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_or_udp_instantiation, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( identifier [ IF( peek(1) == _TLpar && ( peek(2) == _Tsupply1 || peek(2) == _Tsupply0 || peek(2) == _Tweak1 || peek(2) == _Tpull0 || peek(2) == _Tstrong0 || peek(2) == _Tpull1 || peek(2) == _Tstrong1 || peek(2) == _Thighz0 || peek(2) == _Tweak0 || peek(2) == _Thighz1 ) ) drive_strength ] [ parameter_value_assignment_or_delay2 ] module_or_udp_instance { TComma (. addTerminal(); .) module_or_udp_instance } TSemi (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

module_or_udp_instance = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_module_or_udp_instance, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ identifier ] [ range ] TLpar (. addTerminal(); .) [ port_connection_or_output_terminal { TComma (. addTerminal(); .) port_connection_or_output_terminal } ] TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

port_connection_or_output_terminal = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_port_connection_or_output_terminal, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( TDot (. addTerminal(); .) port_identifier TLpar (. addTerminal(); .) [ expression ] TRpar (. addTerminal(); .) 
    | [ expression_2 ] ) (. d_stack.pop(); .) 
    .

parameter_value_assignment_or_delay2 = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_parameter_value_assignment_or_delay2, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( THash (. addTerminal(); .) [ delay_value ] TLpar (. addTerminal(); .) ( mintypmax_expression { TComma (. addTerminal(); .) mintypmax_expression } | named_parameter_assignment { TComma (. addTerminal(); .) named_parameter_assignment } ) TRpar (. addTerminal(); .) ) (. d_stack.pop(); .) 
    .

expression_2 = 
    (. Vl::SynTree* n = new Vl::SynTree( Vl::SynTree::R_expression_2, d_next ); d_stack.top()->d_children.append(n); d_stack.push(n); .) ( [ unary_operator ] primary_2 { expression_nlr } ) (. d_stack.pop(); .) 
    .

primary_2 = 
    ( hierarchical_identifier_range | system_function_identifier ) [ TLpar (. addTerminal(); .) expression { TComma (. addTerminal(); .) expression } TRpar (. addTerminal(); .) | TLbrace (. addTerminal(); .) net_lvalue { TComma (. addTerminal(); .) net_lvalue } TRbrace (. addTerminal(); .) ] 
    | number 
    | string 
    | TLpar (. addTerminal(); .) mintypmax_expression TRpar (. addTerminal(); .) 
    | TLbrace (. addTerminal(); .) expression [ TComma (. addTerminal(); .) expression { TComma (. addTerminal(); .) expression } | TLbrace (. addTerminal(); .) expression { TComma (. addTerminal(); .) expression } TRbrace (. addTerminal(); .) ] TRbrace (. addTerminal(); .) 
    .

END Verilog05 .
