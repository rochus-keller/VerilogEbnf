/*
* Copyright 2019 Rochus Keller <mailto:me@rochus-keller.ch>
*
* This file is part of the VerilogEbnf application.
*
* The following is the license that applies to this copy of the
* application. For a license to use the application under conditions
* other than those described here, please email to me@rochus-keller.ch.
*
* GNU General Public License Usage
* This file may be used under the terms of the GNU General Public
* License (GPL) versions 2.0 or 3.0 as published by the Free Software
* Foundation and appearing in the file LICENSE.GPL included in
* the packaging of this file. Please review the following information
* to ensure GNU General Public Licensing requirements will be met:
* http://www.fsf.org/licensing/licenses/info/GPLv2.html and
* http://www.gnu.org/copyleft/gpl.html.
*/

#include "BisonGen.h"
#include "CocoGen.h"
#include <Verilog/VlToken.h>
#include <QFile>
#include <QTextStream>
using namespace Vl;

BisonGen::BisonGen(Syntax* syn,QObject *parent) : QObject(parent),d_syn(syn)
{
    Q_ASSERT( syn != 0 );
}

void BisonGen::generate(const QString& path, bool buildAst)
{
    Selection selection;
    const Syntax::Definition* root = d_syn->getDef("translation_unit");
    if( root )
    {
        selection.insert(root);
        CocoGen::findAllUsedProductions( d_syn, root->d_node, selection );
    }

    QFile f(path);
    f.open( QIODevice::WriteOnly );
    QTextStream out(&f);
    out.setCodec("Latin-1");

    out << "/* This file was automatically generated by VerilogEbnf; don't modify it! */" << endl;


    out << "%{" << endl;
    out << "extern int yylex();" << endl;
    out << "extern void yyerror (char const *);" << endl;
    out << "%}" << endl;

    out << endl;

    int t = 0;
    for( t = Tok_Plus; t < Tok_Comment; t++ )
    {
        out << "%token " << tokenDef(t) << " " << t << endl;
    }

    out << endl;

    out << "%start Verilog05" << endl << endl;

    out << "%%" << endl;
    out << endl;

    out << "Verilog05: translation_unit ;" << endl << endl;

    out << endl;

    foreach( const Syntax::Definition* d, d_syn->getDefsInOrder() )
    {
        if( d->d_node == 0 || !selection.contains(d) )
            continue;
        writeNode( out, d->d_node, CocoGen::nodeName(d->d_name) );
    }

    out << "%%" << endl;
}

QString BisonGen::tokenDef(quint8 t)
{
    QString tok = tokenName(t);
    tok = tok.mid(4).toUpper();
    if( !tok.isEmpty() && tok[0].isDigit() )
        tok = QChar('T') + tok;
    return tok;
}

void BisonGen::writeNode(QTextStream& out, Syntax::Node* node, const QString& name)
{
    // Konvertiert EBNF in BNF
    // see https://stackoverflow.com/questions/2466484/converting-ebnf-to-bnf
    if( node == 0 )
        return;

    // Syntax::Node::One: einfach hinschreiben
    // Syntax::Node::ZeroOrOne: option mit epsilon
    // Syntax::Node::ZeroOrMore

    const QString myName = name;

    out << myName << " : " << endl << "    ";

    switch( node->d_quant )
    {
    case Syntax::Node::ZeroOrOne:
        out << "%empty " << endl << "    | ";
        break;
    case Syntax::Node::ZeroOrMore:
        out << "%empty " << endl << "    | " << myName << " ";
        break;
    }

    int number = 0;
    QList< QPair<Syntax::Node*,QString> > denormalize;

    switch( node->d_type )
    {
    case Syntax::Node::Terminal:
        out << tokenDef( node->d_lexTok ) << " ";
        break;
    case Syntax::Node::Literal:
        out << "\'" << node->d_name << "\' ";
        break;
    case Syntax::Node::DefRef:
        out << CocoGen::nodeName(node->d_name) << " ";
        break;
    case Syntax::Node::Alternative:
    case Syntax::Node::Sequence:
        for( int i = 0; i < node->d_subs.size(); i++ )
        {
            switch( node->d_subs[i]->d_type )
            {
            case Syntax::Node::Terminal:
                if( node->d_subs[i]->d_quant != Syntax::Node::One )
                {
                    const QString newName = QString( "%1_%2").arg(name).arg(++number);
                    out << newName << " ";
                    denormalize.append( qMakePair(node->d_subs[i],newName) );
                }else
                    out << tokenDef( node->d_subs[i]->d_lexTok ) << " ";
                break;
            case Syntax::Node::Literal:
                if( node->d_subs[i]->d_quant != Syntax::Node::One )
                {
                    const QString newName = QString( "%1_%2").arg(name).arg(++number);
                    out << newName << " ";
                    denormalize.append( qMakePair(node->d_subs[i],newName) );
                }else
                    out << "\'" << node->d_subs[i]->d_name << "\' ";
                break;
            case Syntax::Node::DefRef:
                if( node->d_subs[i]->d_quant != Syntax::Node::One )
                {
                    const QString newName = QString( "%1_%2").arg(name).arg(++number);
                    out << newName << " ";
                    denormalize.append( qMakePair(node->d_subs[i],newName) );
                }else
                    out << CocoGen::nodeName(node->d_subs[i]->d_name) << " ";
                break;
            case Syntax::Node::Alternative:
            case Syntax::Node::Sequence:
                {
                    const QString newName = QString( "%1_%2").arg(name).arg(++number);
                    out << newName << " ";
                    denormalize.append( qMakePair(node->d_subs[i],newName) );
                }
                break;
            }
            if( node->d_type == Syntax::Node::Alternative && i < node->d_subs.size() - 1 )
                out << endl << "    | ";
        }
    }

    out << endl << "    ;" << endl << endl;

    for( int i = 0; i < denormalize.size(); i++ )
    {
        writeNode( out, denormalize[i].first, denormalize[i].second );
    }

}

